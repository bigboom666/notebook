# Binder
进程间的通信
binder机制是贯穿整个android系统的进程间访问机制，经常被用来访问service


Q: Android为什么不使用linux原有的一些手段，比如管道，共享内存，socket等方式，而是采用了Binder作为主要机制？  
A: 效率，安全性。Binder只需要一次拷贝，性能仅次于共享内存，而且采用的传统的C/S结构，稳定性也是没得说，发送添加UID/PID，安全性高



进程隔离
我们知道进程之间是无法直接进行交互的，每个进程独享自己的数据，而且操作系统为了保证自身的安全稳定性，将系统内核空间和用户空间分离开来，保证用户程序进程崩溃时不会影响到整个系统，简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（UserSpace）是用户程序运行的空间。为了保证安全性，它们之间是隔离的，所以用户空间的进程要进行交互需要通过内核空间来驱动整个过程。



C/S结构
client拿到Binder实体对象对应的地址去访问Server
>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。


Binder通信模型  
Binder基于C/S的结构下，定义了4个角色：Server、Client、ServerManager、Binder驱动，其中前三者是在用户空间的，也就是彼此之间无法直接进行交互，Binder驱动是属于内核空间的，属于整个通信的核心，虽然叫驱动，但是实际上和硬件没有太大关系，只是实现的方式和驱动差不多，驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。



代码 

在onBinder方法中返回binder，binder包含了service的句柄，客户端得到句柄以后就可以调用servcie的公共方法了，这种调用方式是最常见的。
