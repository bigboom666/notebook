# 多态
## 向上转型
```java 
Shape s = new Circle();
```
后期绑定使得 s.draw()调用的还是Circle的draw()。

## 动态绑定
### 关于final，static，private和构造方法是前期绑定的理解
- private的方法，首先一点它**不能被继承**，既然不能被继承那么就没办法通过它子类的对象来调用，而只能通过这个类自身的对象来调用。因此就可以说private方法和定义这个方法的类绑定在了一起。
- final方法虽然可以被继承，但**不能被重写（覆盖）**，虽然子类对象可以调用，但是调用的都是父类中所定义的那个final方法，（由此我们可以知道将方法声明为final类型，一是为了防止方法被覆盖，二是为了有效地关闭java中的动态绑定)。
- 构造方法也是不能被继承的（网上也有说子类无条件地继承父类的无参数构造函数作为自己的构造函数，不过个人认为这个说法不太恰当，因为我们知道子类是通过super()来调用父类的无参构造方法，来完成对父类的初始化,而我们使用从父类继承过来的方法是不用这样做的，因此不应该说子类继承了父类的构造方法），因此编译时也可以知道这个构造方法到底是属于哪个类。
- 对于static方法，具体的原理我也说不太清。不过根据网上的资料和我自己做的实验可以得出结论：**static方法可以被子类继承，但是不能被子类重写（覆盖），但是可以被子类隐藏**。（这里意思是说如果父类里有一个static方法，它的子类里如果没有对应的方法，那么当子类对象调用这个方法时就会使用父类中的方法。而如果子类中定义了相同的方法，则会调用子类的中定义的方法。唯一的不同就是，当子类对象上转型为父类对象时，不论子类中有没有定义这个静态方法，该对象都会使用父类中的静态方法。因此这里说静态方法可以被隐藏而不能被覆盖。这与子类隐藏父类中的成员变量是一样的。隐藏和覆盖的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏的变量和方法，而不能访问父类被覆盖的方法）
- 由上面我们可以得出结论，**如果一个方法不可被继承或者继承后不可被覆盖，那么这个方法就采用的静态绑定**。

### 动态绑定针对方法而非成员
```java
public class TestPolymorphism {
    public static void main(String[] args) {
        Father son = new Son();
        
        System.out.println(son.name);//father
        //子类的对象(由父类的引用handle)调用到的是父类的成员变量。所以必须明确，运行时（动态）绑定针对的范畴只是对象的方法。
        //怎么得到子类的成员变量？
        //既然动态绑定针对方法，那就整个方法。
        System.out.println(son.getName());//son
    }
}

class Father {
    String name = "father";
    public String getName() {
        return name;
    }
}

class Son extends Father{
    String name = "son";
    @Override
    public String getName() {
        return name;
    }
}
```
