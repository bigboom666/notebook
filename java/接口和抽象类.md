[TOC]
## 抽象类
```java
[public] abstract class ClassName {
    abstract void fun();
}
```
- 如果一个类**含有抽象方法**，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。
- 抽象类中含有无具体实现的方法，所以**不能用抽象类创建对象**。  
- 抽象类就是为了**继承**而存在的。

### 与普通类区别
- 修饰符：(继承角度)抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
- 抽象类不能用来创建对象。
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。



## 接口
```java
[public] interface InterfaceName {
}

class ClassName implements Interface1,Interface2,[....]{
}
```
- 修饰符：接口中可以有变量和方法。变量：[public static final];方法:[public abstract]。都被隐式指定，且不能改变。
- (彻底抽象)接口中方法不能有具体实现。
- 允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

### 通过接口引用对象
存在适当的接口类型时，应该优先使用接口而不是类来引用对象
```java
    //Good - use interface as type
    List<？> list= new Vector<？>();
    
    //Bad - use class as type
    Vector<?> list= new Vector<?>();
```
- 优点：  
1.假如一个类实现了多个接口,那么用接口类型来定义它的引用变量的话,一眼就可以明白,这里是需要这个类的哪些方法。  
2.程序更加灵活。当你决定更换实现时，只需要改变构造器中类的名称。其他使用list地方的代码根本不需要改动。第一个声明可以被改变为：`List<?> list= new ArrayList<?>();`

- 适合于用类来引用对象的情形：  
1. 如果没有合适的接口存在，可以用类来引用对象。  
>例如，考虑值类（String、BigInteger）很少用多个实现编写，他们通常是final的，并且很少有对应的接口。使用这种值类作为参数、变量、域或者返回值类型就比较合适。  

2. 对象属于一个框架，而框架的基本类型是类，不是接口。（对象属于基于类的框架）  
>例如java.util.TimerTask抽象类。应该用相关的基类（往往是抽象类）来引用对象，而不是它的实现类。  

3. 类实现了接口，但是它提供了接口中不存在的额外方法。  
>例如LinkedHashMap，程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例。

## 抽象类和接口区别
### 语法层面
- 修饰符，接口的全部限定了。
- 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。  

### 设计层面
- 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。  
>*例：飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。*
- 抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。  
>*什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。*
```java
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
```

## 参考
- [深入理解Java的接口和抽象类](https://www.cnblogs.com/dolphin0520/p/3811437.html)