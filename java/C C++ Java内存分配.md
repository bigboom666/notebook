## C/C++
![C内存分配](https://images2015.cnblogs.com/blog/806053/201707/806053-20170723105227668-1030564330.png)  
![C内存分配](https://pic1.zhimg.com/80/158a24c4c2301b1d170ecb2759419261_hd.jpg)


1. 代码段  
放代码，用来执行。大小在程序运行前就已经确定，并且内存区域通常属于只读。
>一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。
2. 数据段  
全局初始化数据区/静态数据区/常量区  
已初始化的全局变量、静态变量和常量
>整个程序执行过程中都需要访问，因此单独存储管理。
3. 未初始化数据区BSS
未初始化的全局变量
>直接清零
4. 栈区
由编译器自动分配释放，存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容
5. 堆区
用于动态内存分配，malloc/free    

在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。

静态分配：编译器在处理程序源代码时分配。  
动态分配：程序在执行时调用malloc库函数申请分配。  

为什么栈向下增长？
>历史：在没有MMU的时代，为了最大的利用内存空间，堆和栈被设计为从两端相向生长。  
现代程序的下列特征，导致内存布局问题中的单个栈增长方向无所谓。  
1.使用线性虚拟地址，进程空间为4G或者更高  
2.现代程序写法，栈的大小1M左右已经足够使用。编译器一般都直接限制栈的大小  
3.多线程导致有多个栈，所以堆-栈的两端分割模式是不合适的，每个栈应当有界  

[为什么栈和堆的生长方向不一样](https://blog.csdn.net/unix21/article/details/8531875)  
[栈为什么要由高地址向低地址扩展？](https://www.zhihu.com/question/29520755)



## Java
![Java内存分配](https://upload-images.jianshu.io/upload_images/650075-0f13c91f8f69e62c.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)    

![Java内存分配](https://img-blog.csdn.net/20180102165046608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)    

1. 程序计数器（物理PC）
2. 虚拟机栈   

Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  

 ![栈帧](https://img-blog.csdn.net/20180102180455895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  


- 程序员主要关注的**stack栈内存**，就是虚拟机栈中**局部变量表部分**。局部变量表存放了编译时期可知的各种基本数据类型和对象引用。
- 基本数据和对象引用存储在栈中--针对局部变量。如果是成员变量，或者定义在方法外对象的引用，它们存储在堆中。  
- Java虚拟机规范对这个区域规定了两种异常情况： 
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；
如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常   
3. 本地方法栈
作用与虚拟机栈相似，但服务对象不同：虚拟机栈--为虚拟机执行Java方法服务（也就是字节码），本地方法栈--为虚拟机使用到的Native方法服务。


4. Java堆  
- 存放对象实例和数组。  
- Java堆是垃圾回收器管理的主要区域，因此也被称为"GC堆"。
从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；
- 如果在堆上没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出OutOfMemoryError异常。

5. 方法区
- 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等
- 运行时常量池：在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。


定义	|成员变量|	局部变量	|静态变量  
----|-------------|-------------|-------------
定义位置|	在类中，方法外	|方法中，或形参	|类中，方法外（java只有静态成员变量）  
初始化值	|有默认初始化值	|无，先定义，后赋值	|默认初始化值  
存储位置	|堆	|栈|	方法区  
声明周期|	与对象共存亡|	与方法(线程)共存亡	|与类共存亡  
别名|	实例变量|	|	类变量  
